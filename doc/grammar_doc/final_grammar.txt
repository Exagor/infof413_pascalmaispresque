[1] <Program> 		    → begin <Code> end
[2] <Code> 		        → <InstList> 
[3]                     → epsilon 
[4] <InstList> 		    → <Instruction> <Instruction_end> // on a géré l'ambiguité comme dans le tp avec le if
[5] <Instruction_end> 	→ epsilon
[6] 			        → ... <InstList>
[7] <Instruction> 	    → <Assign>
[8] 			        → <If>
[9] 			        → <While>
[10]   			        → <Print>
[11]   			        → <Read>
[12]   			        → begin <InstList> end
[13]  <Assign> 		    → [VarName] := <ExprArith>
[14]  <ExprArith> 	    → <MultExpr><ExprArith'>	// on a établis les priorité, la left associativity et enlevé la left récursion
[15]  <ExprArith'>	    → <AddOp> <MultExpr> <ExprArith'>
[16]   			        → epsilon
[17]  <MultExpr> 	    → <term> <MutExpr'>
[18]  <MultExpr'>	    → <MultOp> <Term> <MultExpr'>
[19]   			        → epsilon
[20]  <Term> 		    → (<ExprArith>)
[21]  			        → - <ExprArith>
[22]   			        → [VARNAME]
[23]   			        → [NUMBER]
[24]  <AddOp> 		    → +
[25]   			        → -
[26]  <MultOp>		    → *
[27]   			        → /
[28]  <If> 		        → if <Cond> then <Instruction> else <If-tail>  //on a géré l'ambguité comme dans le tp avec un if-tail
[29]  <If-tail>		    → espilon
[30]   			        → <Instruction>
[31]  <Cond> 		    → <AndCond> <OrCond>		// on enlève la left récursion et on établi la priporité entre and et or
[32]  <OrCond> 		    → or <AndCond> <OrCond>
[33]  			        → epsilon
[34]  <AndCond> 		→ <End-Condition> <AndCond'>
[35]  <AndCond'> 	    → and <EndCondition> <AndCond'>
[36]   			        → epsilon
[37]  <EndCondition>	→ { <Cond> }
[38]   			        → <SimpleCond>
[39]  <SimpleCond> 	    → <ExprArith> <Comp> <ExprArith>
[40]  <Comp> 		    → =
[41]   			        → <
[42]  <While> 		    → while <Cond> do <Instruction>
[43]  <Print> 		    → print([VarName])
[45]  <Read> 		    → read([VarName])