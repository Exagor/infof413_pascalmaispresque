[1] <Program> 		→ begin <Code> end
[2] <Code> 		    → ε
[3] 			    → <InstList>
[4] <InstList> 		→ <Instruction'> <Instruction_end> // on a géré l'ambiguité comme dans le tp avec le if
[a] <Instruction_end> 	→ epsilon
[5] 			→ ... <InstList>
[6] <Instruction> 	→ <Assign>
[7] 			→ <If>
[8] 			→ <While>
[9] 			→ <For>
[10] 			→ <Print>
[11] 			→ <Read>
[12] 			→ begin <InstList> end
[13] <Assign> 		→ [VarName] := <ExprArith>
[14] <ExprArith> 	→ <MultExpr><ExprArith'>	// on a établis les priorité, la left associativity et enlevé la left récursion
[aa] <ExprArith'>	→ <AddOp> <MultExpr> <ExprArith'>
[aa] 			→ epsilon
[15]			→ <MultExpr>
[16] <MultExpr> 	→ <term> <MutExpr'>
[aa] <MultExpr'>	→ <MultOp> <Term> <MultExpr'>
[aa] 			→ epsilon
[18] <Term> 		→ <(ExprArith>)
[aa]			→ - <ExprArith>
[19] 			→ [VARNAME]
[20] 			→ [NUMBER]
[19] <AddOp> 		→ +
[20] 			→ -
[21] <MultOp>		→ *
[22] 			→ /
[23] <If> 		→ if <Cond> then <Instruction> <If-tail>  //on a géré l'ambguité comme dans le tp avec un if-tail
[aa] <If-tail>		→ espilon
[24] 			→ else <Instruction>
[25] <Cond> 		→ <OrCond> <Cond'>		// on enlève la left récursion et on établi la priporité entre and et or
[aa] <Cond'> 		→ or <Cond'>
[aa]			→ epsilon
[bb] <AndCond> 		→ <End-Condition> <AndCond'>
[bb] <AndCond'> 	→ and <AndCond'>
[bb] 			→ epsilon
[aa] <EndCondition>	→ { <Cond> }
[28] 			→ <SimpleCond>
[29] <SimpleCond> 	→ <ExprArith> <Comp> <ExprArith>
[30] <Comp> 		→ =
[31] 			→ <
[32] <While> 		→ while <Cond> do <Instruction>
[33] <Print> 		→ print([VarName])
[34] <Read> 		→ read([VarName])








[14] <ExprArith> 	→ <ExprArith> <AddOp> <MultExpr>
[15]			→ <MultExpr>
[16] <MultExpr> 	→ <MultExpr> <multOp> <term>
[17] 			→ <term>
[18] <term> 		→ <(ExprArith>)
[19] 			→ [VARNAME]
[20] 			→ [NUMBER]
[19] <AddOp> 		→ +
[20] 			→ -
[21] <multOp>		→ *
[22] 			→ /


[25] <Cond> 		→ <OrCond> <Cond'>		// on enlève la left récursion et on établi la priporité and > or
[aa] <Cond'> 		→ and <Cond'>
[aa]			→ epsilon
[bb] <OrCond> 		→ <End-Condition> <OrCond'>
[bb] <OrCond'> 		→ or <OrCond'>
[bb] 			→ epsilon
[aa] <EndCondition>	→ { <Cond> }
[28] 			→ <SimpleCond>


